"use strict";
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("../utils/utils");
const filter_interface_nodes_1 = __importDefault(require("../utils/filter-interface-nodes"));
// eslint-disable-next-line import/no-cycle
const create_connection_and_params_1 = __importDefault(require("./connection/create-connection-and-params"));
const create_auth_and_params_1 = require("./create-auth-and-params");
// eslint-disable-next-line import/no-cycle
const create_projection_and_params_1 = __importDefault(require("./create-projection-and-params"));
const get_relationship_direction_1 = require("../utils/get-relationship-direction");
const CypherBuilder = __importStar(require("./cypher-builder/CypherBuilder"));
const add_sort_and_limit_to_clause_1 = require("./projection/subquery/add-sort-and-limit-to-clause");
const utils_2 = require("./cypher-builder/utils/utils");
const create_where_predicate_1 = require("./where/create-where-predicate");
const constants_1 = require("../constants");
function createInterfaceProjectionAndParams({ resolveTree, field, context, nodeVariable, withVars, }) {
    const fullWithVars = (0, utils_1.removeDuplicates)([...(0, utils_1.asArray)(withVars), nodeVariable]);
    const parentNode = new CypherBuilder.NamedNode(nodeVariable);
    const whereInput = resolveTree.args.where;
    const returnVariable = `${nodeVariable}_${field.fieldName}`;
    const referenceNodes = context.nodes.filter((node) => field.interface?.implementations?.includes(node.name) && (0, filter_interface_nodes_1.default)({ node, whereInput }));
    const subqueries = referenceNodes.map((refNode) => {
        return createInterfaceSubquery({
            refNode,
            nodeVariable,
            field,
            resolveTree,
            context,
            parentNode,
            fullWithVars,
        });
    });
    const optionsInput = resolveTree.args.options;
    let withClause;
    if (optionsInput) {
        withClause = new CypherBuilder.With("*");
        (0, add_sort_and_limit_to_clause_1.addSortAndLimitOptionsToClause)({
            optionsInput,
            projectionClause: withClause,
            target: new CypherBuilder.NamedNode(returnVariable),
        });
    }
    const unionClause = new CypherBuilder.Union(...subqueries);
    const call = new CypherBuilder.Call(unionClause);
    return new CypherBuilder.RawCypher((env) => {
        const subqueryStr = call.getCypher(env);
        const withStr = (0, utils_2.compileCypherIfExists)(withClause, env, { suffix: "\n" });
        let interfaceProjection = [`WITH ${fullWithVars.join(", ")}`, subqueryStr];
        if (field.typeMeta.array) {
            interfaceProjection = [
                `WITH *`,
                "CALL {",
                ...interfaceProjection,
                `${withStr}RETURN collect(${returnVariable}) AS ${returnVariable}`,
                "}",
            ];
        }
        return interfaceProjection.join("\n");
    });
}
exports.default = createInterfaceProjectionAndParams;
function createInterfaceSubquery({ refNode, nodeVariable, field, resolveTree, context, parentNode, fullWithVars, }) {
    const whereInput = resolveTree.args.where;
    const param = `${nodeVariable}_${refNode.name}`;
    const relatedNode = new CypherBuilder.NamedNode(param, {
        labels: [refNode.name], // NOTE: should this be labels?
    });
    const relationshipRef = new CypherBuilder.Relationship({
        source: parentNode,
        target: relatedNode,
        type: field.type,
    });
    const direction = (0, get_relationship_direction_1.getRelationshipDirection)(field, resolveTree.args);
    const pattern = relationshipRef.pattern({
        source: {
            labels: false,
        },
        directed: direction !== "undirected",
    });
    if (direction === "IN")
        pattern.reverse();
    const withClause = new CypherBuilder.With(...fullWithVars.map((f) => new CypherBuilder.NamedVariable(f)));
    const matchQuery = new CypherBuilder.Match(pattern);
    const authAllowPredicate = (0, create_auth_and_params_1.createAuthPredicates)({
        entity: refNode,
        operations: "READ",
        allow: {
            parentNode: refNode,
            varName: relatedNode,
        },
        context,
    });
    if (authAllowPredicate) {
        const apocValidateClause = new CypherBuilder.apoc.ValidatePredicate(CypherBuilder.not(authAllowPredicate), constants_1.AUTH_FORBIDDEN_ERROR);
        matchQuery.where(apocValidateClause);
    }
    if (resolveTree.args.where) {
        const whereInput2 = {
            ...Object.entries(whereInput).reduce((args, [k, v]) => {
                if (k !== "_on") {
                    return { ...args, [k]: v };
                }
                return args;
            }, {}),
            ...(whereInput?._on?.[refNode.name] || {}),
        };
        const wherePredicate = (0, create_where_predicate_1.createWherePredicate)({
            whereInput: whereInput2,
            context,
            targetElement: relatedNode,
            element: refNode,
        });
        if (wherePredicate) {
            matchQuery.where(wherePredicate);
        }
    }
    const whereAuthPredicate = (0, create_auth_and_params_1.createAuthPredicates)({
        entity: refNode,
        operations: "READ",
        where: {
            node: refNode,
            varName: relatedNode,
        },
        context,
    });
    if (whereAuthPredicate) {
        matchQuery.where(whereAuthPredicate);
    }
    const { projection: projectionStr, params: projectionParams, meta, subqueries: projectionSubQueries, } = (0, create_projection_and_params_1.default)({
        resolveTree,
        node: refNode,
        context,
        varName: param,
        literalElements: true,
        resolveType: true,
    });
    let connectionClauses = [];
    if (meta?.connectionFields?.length) {
        connectionClauses = meta.connectionFields.map((connectionResolveTree) => {
            return new CypherBuilder.RawCypher(() => {
                const connectionField = refNode.connectionFields.find((x) => x.fieldName === connectionResolveTree.name);
                const connection = (0, create_connection_and_params_1.default)({
                    resolveTree: connectionResolveTree,
                    field: connectionField,
                    context,
                    nodeVariable: param,
                });
                return [connection[0], projectionParams];
            });
        });
    }
    const projectionSubqueryClause = CypherBuilder.concat(...projectionSubQueries);
    const returnClause = new CypherBuilder.Return([
        new CypherBuilder.RawCypher(projectionStr),
        `${nodeVariable}_${field.fieldName}`,
    ]);
    return CypherBuilder.concat(withClause, matchQuery, ...connectionClauses, projectionSubqueryClause, returnClause);
}
//# sourceMappingURL=create-interface-projection-and-params.js.map