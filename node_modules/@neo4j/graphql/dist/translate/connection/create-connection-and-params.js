"use strict";
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const graphql_relay_1 = require("graphql-relay");
const utils_1 = require("@graphql-tools/utils");
// eslint-disable-next-line import/no-cycle
const create_projection_and_params_1 = __importDefault(require("../create-projection-and-params"));
const create_relationship_property_element_1 = __importDefault(require("../projection/elements/create-relationship-property-element"));
const create_connection_where_and_params_1 = __importDefault(require("../where/create-connection-where-and-params"));
const create_auth_and_params_1 = require("../create-auth-and-params");
const constants_1 = require("../../constants");
const pagination_1 = require("../../schema/pagination");
const filter_interface_nodes_1 = __importDefault(require("../../utils/filter-interface-nodes"));
const utils_2 = require("../../utils/utils");
const resolveTree_1 = require("../utils/resolveTree");
const get_relationship_direction_1 = require("../../utils/get-relationship-direction");
const CypherBuilder = __importStar(require("../cypher-builder/CypherBuilder"));
function createConnectionAndParams({ resolveTree, field, context, nodeVariable, parameterPrefix, withVars, }) {
    let globalParams = {};
    let nestedConnectionFieldParams;
    const withVarsAndNodeName = (0, utils_2.removeDuplicates)([...(0, utils_2.asArray)(withVars), nodeVariable]);
    let subquery = ["CALL {", `WITH ${withVarsAndNodeName.join(", ")}`];
    const sortInput = (resolveTree.args.sort ?? []);
    // Fields of {edge, node} to sort on. A simple resolve tree will be added if not in selection set
    // Since nodes of abstract types and edges are constructed sort will not work if field is not in selection set
    const edgeSortFields = sortInput.map(({ edge = {} }) => Object.keys(edge)).flat();
    const nodeSortFields = sortInput.map(({ node = {} }) => Object.keys(node)).flat();
    const afterInput = resolveTree.args.after;
    const firstInput = resolveTree.args.first;
    const whereInput = resolveTree.args.where;
    const relationshipVariable = `${nodeVariable}_${field.relationship.type.toLowerCase()}_relationship`;
    const relationship = context.relationships.find((r) => r.name === field.relationshipTypeName);
    const relatedNode = context.nodes.find((x) => x.name === field.relationship.typeMeta.name);
    const relTypeStr = `[${relationshipVariable}:${field.relationship.type}]`;
    const { inStr, outStr } = (0, get_relationship_direction_1.getRelationshipDirectionStr)(field.relationship, resolveTree.args);
    let relationshipProperties = [];
    let node;
    const connection = resolveTree.fieldsByTypeName[field.typeMeta.name];
    if (connection.edges) {
        const relationshipFieldsByTypeName = connection.edges.fieldsByTypeName[field.relationshipTypeName];
        relationshipProperties = Object.values(relationshipFieldsByTypeName).filter((v) => v.name !== "node");
        edgeSortFields.forEach((sortField) => {
            // For every sort field on edge check to see if the field is in selection set
            if (!relationshipProperties.find((rt) => rt.name === sortField) ||
                relationshipProperties.find((rt) => rt.name === sortField && rt.alias !== sortField)) {
                // if it doesn't exist add a basic resolve tree to relationshipProperties
                relationshipProperties.push({ alias: sortField, args: {}, fieldsByTypeName: {}, name: sortField });
            }
        });
        node = Object.values(relationshipFieldsByTypeName).find((v) => v.name === "node");
    }
    const elementsToCollect = [];
    if (relationshipProperties.length) {
        const relationshipPropertyEntries = relationshipProperties
            .filter((p) => p.name !== "cursor")
            .map((v) => (0, create_relationship_property_element_1.default)({ resolveTree: v, relationship, relationshipVariable }));
        elementsToCollect.push(relationshipPropertyEntries.join(", "));
    }
    if (field.relationship.union || field.relationship.interface) {
        const relatedNodes = field.relationship.union
            ? context.nodes.filter((n) => field.relationship.union?.nodes?.includes(n.name))
            : context.nodes.filter((x) => field.relationship?.interface?.implementations?.includes(x.name) &&
                (0, filter_interface_nodes_1.default)({ node: x, whereInput: whereInput?.node }));
        const subqueries = [];
        relatedNodes.forEach((n) => {
            if (!whereInput ||
                Object.prototype.hasOwnProperty.call(whereInput, n.name) ||
                (field.relationship.interface &&
                    !field.relationship.interface?.implementations?.some((i) => Object.prototype.hasOwnProperty.call(resolveTree.args.where, i)))) {
                const labels = n.getLabelString(context);
                const relatedNodeVariable = `${nodeVariable}_${n.name}`;
                const nodeOutStr = `(${relatedNodeVariable}${labels})`;
                const unionInterfaceSubquery = [];
                const subqueryElementsToCollect = [...elementsToCollect];
                const nestedSubqueries = [];
                if (node) {
                    const selectedFields = (0, utils_1.mergeDeep)([
                        node.fieldsByTypeName[n.name],
                        ...n.interfaces.map((i) => node?.fieldsByTypeName[i.name.value]),
                    ]);
                    const mergedResolveTree = (0, utils_1.mergeDeep)([
                        node,
                        {
                            ...node,
                            fieldsByTypeName: {
                                [n.name]: (0, resolveTree_1.generateMissingOrAliasedFields)({
                                    fieldNames: nodeSortFields,
                                    selection: selectedFields,
                                }),
                            },
                        },
                    ]);
                    const nodeProjectionAndParams = (0, create_projection_and_params_1.default)({
                        resolveTree: mergedResolveTree,
                        node: n,
                        context,
                        varName: relatedNodeVariable,
                        literalElements: true,
                        resolveType: true,
                    });
                    const { projection: nodeProjection, params: nodeProjectionParams } = nodeProjectionAndParams;
                    subqueryElementsToCollect.push(`node: ${nodeProjection}`);
                    globalParams = {
                        ...globalParams,
                        ...nodeProjectionParams,
                    };
                    if (nodeProjectionAndParams.meta?.connectionFields?.length) {
                        nodeProjectionAndParams.meta.connectionFields.forEach((connectionResolveTree) => {
                            const connectionField = n.connectionFields.find((x) => x.fieldName === connectionResolveTree.name);
                            const nestedConnection = createConnectionAndParams({
                                resolveTree: connectionResolveTree,
                                field: connectionField,
                                context,
                                nodeVariable: relatedNodeVariable,
                                parameterPrefix: `${parameterPrefix ? `${parameterPrefix}.` : `${nodeVariable}_`}${resolveTree.alias}.edges.node`,
                                withVars: withVarsAndNodeName,
                            });
                            nestedSubqueries.push(nestedConnection[0]);
                            globalParams = {
                                ...globalParams,
                                ...Object.entries(nestedConnection[1]).reduce((res, [k, v]) => {
                                    if (k !== `${relatedNodeVariable}_${connectionResolveTree.alias}`) {
                                        res[k] = v;
                                    }
                                    return res;
                                }, {}),
                            };
                            if (nestedConnection[1][`${relatedNodeVariable}_${connectionResolveTree.alias}`]) {
                                if (!nestedConnectionFieldParams)
                                    nestedConnectionFieldParams = {};
                                nestedConnectionFieldParams = {
                                    ...nestedConnectionFieldParams,
                                    ...{
                                        [connectionResolveTree.alias]: nestedConnection[1][`${relatedNodeVariable}_${connectionResolveTree.alias}`],
                                    },
                                };
                            }
                        });
                    }
                }
                else {
                    // This ensures that totalCount calculation is accurate if edges not asked for
                    subqueryElementsToCollect.push(`node: { __resolveType: "${n.name}" }`);
                }
                unionInterfaceSubquery.push(`WITH ${nodeVariable}`);
                unionInterfaceSubquery.push(`MATCH (${nodeVariable})${inStr}${relTypeStr}${outStr}${nodeOutStr}`);
                const whereStrs = [];
                const unionInterfaceWhere = field.relationship.union ? (whereInput || {})[n.name] : whereInput || {};
                if (unionInterfaceWhere) {
                    const where = (0, create_connection_where_and_params_1.default)({
                        whereInput: unionInterfaceWhere,
                        node: n,
                        nodeVariable: relatedNodeVariable,
                        relationship,
                        relationshipVariable,
                        context,
                        parameterPrefix: `${parameterPrefix ? `${parameterPrefix}.` : `${nodeVariable}_`}${resolveTree.alias}.args.where${field.relationship.union ? `.${n.name}` : ""}`,
                    });
                    const [whereClause, whereParams] = where;
                    if (whereClause) {
                        whereStrs.push(whereClause);
                        globalParams = { ...globalParams, ...whereParams };
                    }
                }
                const whereAuth = (0, create_auth_and_params_1.createAuthAndParams)({
                    operations: "READ",
                    entity: n,
                    context,
                    where: { varName: relatedNodeVariable, node: n },
                });
                if (whereAuth[0]) {
                    whereStrs.push(whereAuth[0]);
                    globalParams = { ...globalParams, ...whereAuth[1] };
                }
                if (whereStrs.length) {
                    unionInterfaceSubquery.push(`WHERE ${whereStrs.join(" AND ")}`);
                }
                const allowAndParams = (0, create_auth_and_params_1.createAuthAndParams)({
                    operations: "READ",
                    entity: n,
                    context,
                    allow: {
                        parentNode: n,
                        varName: relatedNodeVariable,
                    },
                });
                if (allowAndParams[0]) {
                    globalParams = { ...globalParams, ...allowAndParams[1] };
                    unionInterfaceSubquery.push(`CALL apoc.util.validate(NOT (${allowAndParams[0]}), "${constants_1.AUTH_FORBIDDEN_ERROR}", [0])`);
                }
                if (nestedSubqueries.length) {
                    unionInterfaceSubquery.push(nestedSubqueries.join("\n"));
                }
                unionInterfaceSubquery.push(`WITH { ${subqueryElementsToCollect.join(", ")} } AS edge`);
                unionInterfaceSubquery.push("RETURN edge");
                subqueries.push(unionInterfaceSubquery.join("\n"));
            }
        });
        const subqueryCypher = ["CALL {", subqueries.join("\nUNION\n"), "}"];
        if (sortInput.length) {
            const sort = sortInput.map((s) => [
                ...Object.entries(s.edge || []).map(([f, direction]) => `edge.${f} ${direction}`),
                ...Object.entries(s.node || []).map(([f, direction]) => `edge.node.${f} ${direction}`),
            ].join(", "));
            subqueryCypher.push(`WITH edge ORDER BY ${sort.join(", ")}`);
        }
        subqueryCypher.push("WITH collect(edge) as edges");
        subquery.push(subqueryCypher.join("\n"));
    }
    else {
        const relatedNodeVariable = `${nodeVariable}_${field.relationship.typeMeta.name.toLowerCase()}`;
        const labels = relatedNode.getLabelString(context);
        const nodeOutStr = `(${relatedNodeVariable}${labels})`;
        subquery.push(`MATCH (${nodeVariable})${inStr}${relTypeStr}${outStr}${nodeOutStr}`);
        const whereStrs = [];
        if (whereInput) {
            const where = (0, create_connection_where_and_params_1.default)({
                whereInput,
                node: relatedNode,
                nodeVariable: relatedNodeVariable,
                relationship,
                relationshipVariable,
                context,
                parameterPrefix: `${parameterPrefix ? `${parameterPrefix}.` : `${nodeVariable}_`}${resolveTree.alias}.args.where`,
            });
            const [whereClause, whereParams] = where;
            if (whereClause) {
                whereStrs.push(`${whereClause}`);
                globalParams = { ...globalParams, ...whereParams };
            }
        }
        const whereAuth = (0, create_auth_and_params_1.createAuthAndParams)({
            operations: "READ",
            entity: relatedNode,
            context,
            where: { varName: relatedNodeVariable, node: relatedNode },
        });
        if (whereAuth[0]) {
            whereStrs.push(whereAuth[0]);
            globalParams = { ...globalParams, ...whereAuth[1] };
        }
        if (whereStrs.length) {
            subquery.push(`WHERE ${whereStrs.join(" AND ")}`);
        }
        const allowAndParams = (0, create_auth_and_params_1.createAuthAndParams)({
            operations: "READ",
            entity: relatedNode,
            context,
            allow: {
                parentNode: relatedNode,
                varName: relatedNodeVariable,
            },
        });
        if (allowAndParams[0]) {
            globalParams = { ...globalParams, ...allowAndParams[1] };
            subquery.push(`CALL apoc.util.validate(NOT (${allowAndParams[0]}), "${constants_1.AUTH_FORBIDDEN_ERROR}", [0])`);
        }
        if (sortInput.length) {
            const sort = sortInput.map((s) => [
                ...Object.entries(s.edge || []).map(([f, direction]) => `${relationshipVariable}.${f} ${direction}`),
                ...Object.entries(s.node || []).map(([f, direction]) => `${relatedNodeVariable}.${f} ${direction}`),
            ].join(", "));
            subquery.push(`WITH ${relationshipVariable}, ${relatedNodeVariable}`);
            subquery.push(`ORDER BY ${sort.join(", ")}`);
        }
        if (node) {
            const nestedSubqueries = [];
            const { projection: nodeProjection, params: nodeProjectionParams, meta: projectionMeta, subqueries: projectionSubqueries, } = (0, create_projection_and_params_1.default)({
                resolveTree: node,
                node: relatedNode,
                context,
                varName: relatedNodeVariable,
                literalElements: true,
            });
            elementsToCollect.push(`node: ${nodeProjection}`);
            globalParams = { ...globalParams, ...nodeProjectionParams };
            if (projectionMeta?.authValidateStrs?.length) {
                subquery.push(`CALL apoc.util.validate(NOT (${projectionMeta.authValidateStrs.join(" AND ")}), "${constants_1.AUTH_FORBIDDEN_ERROR}", [0])`);
            }
            if (projectionMeta?.connectionFields?.length) {
                projectionMeta.connectionFields.forEach((connectionResolveTree) => {
                    const connectionField = relatedNode.connectionFields.find((x) => x.fieldName === connectionResolveTree.name);
                    const nestedConnection = createConnectionAndParams({
                        resolveTree: connectionResolveTree,
                        field: connectionField,
                        context,
                        nodeVariable: relatedNodeVariable,
                        parameterPrefix: `${parameterPrefix ? `${parameterPrefix}.` : `${nodeVariable}_`}${resolveTree.alias}.edges.node`,
                    });
                    nestedSubqueries.push(nestedConnection[0]);
                    globalParams = {
                        ...globalParams,
                        ...Object.entries(nestedConnection[1]).reduce((res, [k, v]) => {
                            if (k !== `${relatedNodeVariable}_${connectionResolveTree.alias}`) {
                                res[k] = v;
                            }
                            return res;
                        }, {}),
                    };
                    if (nestedConnection[1][`${relatedNodeVariable}_${connectionResolveTree.alias}`]) {
                        if (!nestedConnectionFieldParams)
                            nestedConnectionFieldParams = {};
                        nestedConnectionFieldParams = {
                            ...nestedConnectionFieldParams,
                            ...{
                                [connectionResolveTree.alias]: nestedConnection[1][`${relatedNodeVariable}_${connectionResolveTree.alias}`],
                            },
                        };
                    }
                });
            }
            if (nestedSubqueries.length)
                subquery.push(nestedSubqueries.join("\n"));
            if (projectionSubqueries.length > 0) {
                const projectionQuery = CypherBuilder.concat(...projectionSubqueries);
                const projectionSubqueryResult = projectionQuery.build(`${relatedNodeVariable}_connection`);
                subquery.push(projectionSubqueryResult.cypher);
                globalParams = { ...globalParams, ...projectionSubqueryResult.params };
            }
        }
        subquery.push(`WITH collect({ ${elementsToCollect.join(", ")} }) AS edges`);
    }
    const withValues = [];
    const returnValues = [];
    if (relatedNode && relatedNode.queryOptions?.getLimit()) {
        subquery = [
            ...subquery,
            ...createLimitedReturnSubquery(resolveTree.alias, relatedNode.queryOptions.getLimit(), afterInput),
        ];
    }
    else if (!firstInput && !afterInput) {
        if (connection.edges || connection.pageInfo) {
            if (elementsToCollect.length > 0) {
                subquery.push("UNWIND edges as edge");
                withValues.push("collect(edge) AS edges");
                returnValues.push("edges: edges");
                withValues.push("size(collect(edge)) AS totalCount");
                returnValues.push("totalCount: totalCount");
            }
            else {
                withValues.push("edges");
                returnValues.push("edges: edges");
                withValues.push("size(edges) AS totalCount");
                returnValues.push("totalCount: totalCount");
            }
        }
        else {
            withValues.push("size(edges) AS totalCount");
            returnValues.push("totalCount: totalCount");
        }
        if (sortInput.length && elementsToCollect.length > 0) {
            subquery.push("WITH edges, edge");
            const sort = sortInput.map((s) => [
                ...Object.entries(s.edge || []).map(([f, direction]) => `edge.${f} ${direction}`),
                ...Object.entries(s.node || []).map(([f, direction]) => `edge.node.${f} ${direction}`),
            ].join(", "));
            subquery.push(`ORDER BY ${sort.join(", ")}`);
        }
        subquery.push(`WITH ${withValues.join(", ")}`);
        subquery.push(`RETURN { ${returnValues.join(", ")} } AS ${resolveTree.alias}`);
    }
    else {
        subquery = [
            ...subquery,
            ...createLimitedReturnSubquery(resolveTree.alias, firstInput, afterInput),
        ];
    }
    subquery.push("}");
    const params = {
        ...globalParams,
        ...((whereInput || nestedConnectionFieldParams) && {
            [`${nodeVariable}_${resolveTree.alias}`]: {
                ...(whereInput && { args: { where: whereInput } }),
                ...(nestedConnectionFieldParams && { edges: { node: { ...nestedConnectionFieldParams } } }),
            },
        }),
    };
    return [subquery.join("\n"), params];
}
exports.default = createConnectionAndParams;
function createLimitedReturnSubquery(alias, limit, afterInput) {
    const offset = (0, utils_2.isString)(afterInput) ? (0, graphql_relay_1.cursorToOffset)(afterInput) + 1 : undefined;
    const offsetLimitStr = (0, pagination_1.createOffsetLimitStr)({
        offset,
        limit,
    });
    return [
        `WITH size(edges) AS totalCount, edges${offsetLimitStr} AS limitedSelection`,
        `RETURN { edges: limitedSelection, totalCount: totalCount } AS ${alias}`,
    ];
}
//# sourceMappingURL=create-connection-and-params.js.map