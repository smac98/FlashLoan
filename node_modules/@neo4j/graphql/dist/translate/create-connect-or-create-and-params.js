"use strict";
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createConnectOrCreateAndParams = void 0;
const create_auth_and_params_1 = require("./create-auth-and-params");
const constants_1 = require("../constants");
const utils_1 = require("../utils/utils");
const CypherBuilder = __importStar(require("./cypher-builder/CypherBuilder"));
const convert_to_cypher_params_1 = require("./cypher-builder/utils/convert-to-cypher-params");
const callback_utils_1 = require("./utils/callback-utils");
function createConnectOrCreateAndParams({ input, varName, parentVar, relationField, refNode, context, withVars, callbackBucket, }) {
    const withVarsVariables = withVars.map((name) => new CypherBuilder.NamedVariable(name));
    const statements = (0, utils_1.asArray)(input).map((inputItem, index) => {
        const subqueryBaseName = `${varName}${index}`;
        const result = createConnectOrCreatePartialStatement({
            input: inputItem,
            baseName: subqueryBaseName,
            parentVar,
            relationField,
            refNode,
            context,
            varName,
            callbackBucket,
        });
        return result;
    });
    const wrappedQueries = statements.map((statement) => {
        const countResult = new CypherBuilder.RawCypher(() => "COUNT(*) AS _");
        const returnStatement = new CypherBuilder.Return(countResult);
        const withStatement = new CypherBuilder.With(...withVarsVariables);
        const callStatement = new CypherBuilder.Call(CypherBuilder.concat(statement, returnStatement)).with(...withVarsVariables);
        return CypherBuilder.concat(withStatement, callStatement);
    });
    const query = CypherBuilder.concat(...wrappedQueries);
    return query.build(`${varName}_`);
}
exports.createConnectOrCreateAndParams = createConnectOrCreateAndParams;
function createConnectOrCreatePartialStatement({ input, baseName, parentVar, relationField, refNode, context, varName, callbackBucket, }) {
    const mergeQuery = mergeStatement({
        input,
        refNode,
        context,
        relationField,
        parentNode: new CypherBuilder.NamedNode(parentVar),
        varName,
        callbackBucket,
    });
    const authQuery = createAuthStatement({
        node: refNode,
        context,
        nodeName: baseName,
    });
    if (authQuery) {
        return CypherBuilder.concat(authQuery, mergeQuery);
    }
    return mergeQuery;
}
function mergeStatement({ input, refNode, context, relationField, parentNode, varName, callbackBucket, }) {
    const whereNodeParameters = getCypherParameters(input.where?.node, refNode);
    const onCreateNodeParameters = getCypherParameters(input.onCreate?.node, refNode);
    const autogeneratedParams = getAutogeneratedParams(refNode);
    const node = new CypherBuilder.Node({
        labels: refNode.getLabels(context),
    });
    const unsetAutogeneratedParams = (0, utils_1.omitFields)(autogeneratedParams, Object.keys(whereNodeParameters));
    const callbackFields = getCallbackFields(refNode);
    const callbackParams = callbackFields
        .map((callbackField) => {
        const varNameVariable = new CypherBuilder.NamedVariable(varName);
        return (0, callback_utils_1.addCallbackAndSetParamCypher)(callbackField, varNameVariable, parentNode, callbackBucket, "CREATE", node);
    })
        .filter((tuple) => tuple.length !== 0);
    const rawNodeParams = {
        ...unsetAutogeneratedParams,
        ...onCreateNodeParameters,
    };
    const onCreateParams = Object.entries(rawNodeParams).map(([key, param]) => {
        return [node.property(key), param];
    });
    const merge = new CypherBuilder.Merge(node, whereNodeParameters).onCreate(...onCreateParams, ...callbackParams);
    const relationshipFields = context.relationships.find((x) => x.properties === relationField.properties);
    const autogeneratedRelationshipParams = relationshipFields ? getAutogeneratedParams(relationshipFields) : {};
    const rawOnCreateRelationshipParams = (0, convert_to_cypher_params_1.convertToCypherParams)(input.onCreate?.edge || {});
    const rawRelationshipParams = {
        ...autogeneratedRelationshipParams,
        ...rawOnCreateRelationshipParams,
    };
    const relationship = new CypherBuilder.Relationship({
        source: relationField.direction === "IN" ? node : parentNode,
        target: relationField.direction === "IN" ? parentNode : node,
        type: relationField.type,
    });
    const onCreateRelationshipParams = Object.entries(rawRelationshipParams).map(([key, param]) => {
        return [relationship.property(key), param];
    });
    const relationshipMerge = new CypherBuilder.Merge(relationship).onCreate(...onCreateRelationshipParams);
    return CypherBuilder.concat(merge, relationshipMerge);
}
function createAuthStatement({ node, context, nodeName, }) {
    if (!node.auth)
        return undefined;
    const auth = (0, create_auth_and_params_1.createAuthAndParams)({
        entity: node,
        operations: ["CONNECT", "CREATE"],
        context,
        allow: { parentNode: node, varName: nodeName, chainStr: `${nodeName}${node.name}_allow` },
        escapeQuotes: false,
    });
    return new CypherBuilder.RawCypher((env) => {
        const predicate = `NOT (${auth[0]})`;
        const message = constants_1.AUTH_FORBIDDEN_ERROR;
        const cypherStr = `CALL apoc.util.validate(${predicate}, "${message}", [0])`;
        return [cypherStr, auth[1]];
    });
}
function getCallbackFields(node) {
    const callbackFields = node.primitiveFields.filter((f) => f.callback);
    return callbackFields;
}
// Helper for compatibility reasons
function getAutogeneratedParams(node) {
    const autogeneratedFields = node.primitiveFields
        .filter((f) => f.autogenerate)
        .reduce((acc, field) => {
        if (field.dbPropertyName) {
            acc[field.dbPropertyName] = new CypherBuilder.RawCypher("randomUUID()");
        }
        return acc;
    }, {});
    const autogeneratedTemporalFields = node.temporalFields
        .filter((field) => ["DateTime", "Time"].includes(field.typeMeta.name) && field.timestamps?.includes("CREATE"))
        .reduce((acc, field) => {
        if (field.dbPropertyName) {
            acc[field.dbPropertyName] = new CypherBuilder.RawCypher(`${field.typeMeta.name.toLowerCase()}()`);
        }
        return acc;
    }, {});
    return { ...autogeneratedTemporalFields, ...autogeneratedFields };
}
function getCypherParameters(onCreateParams = {}, node) {
    const params = Object.entries(onCreateParams).reduce((acc, [key, value]) => {
        const nodeField = node?.constrainableFields.find((f) => f.fieldName === key);
        const nodeFieldName = nodeField?.dbPropertyName || nodeField?.fieldName;
        const fieldName = nodeFieldName || key;
        const valueOrArray = nodeField?.typeMeta.array ? (0, utils_1.asArray)(value) : value;
        acc[fieldName] = valueOrArray;
        return acc;
    }, {});
    return (0, convert_to_cypher_params_1.convertToCypherParams)(params);
}
//# sourceMappingURL=create-connect-or-create-and-params.js.map