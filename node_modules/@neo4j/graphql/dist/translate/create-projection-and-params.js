"use strict";
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const graphql_1 = require("graphql");
const utils_1 = require("@graphql-tools/utils");
const create_auth_and_params_1 = require("./create-auth-and-params");
const constants_1 = require("../constants");
const create_datetime_element_1 = require("./projection/elements/create-datetime-element");
const create_point_element_1 = __importDefault(require("./projection/elements/create-point-element"));
// eslint-disable-next-line import/no-cycle
const create_connection_and_params_1 = __importDefault(require("./connection/create-connection-and-params"));
const map_to_db_property_1 = __importDefault(require("../utils/map-to-db-property"));
const create_field_aggregation_1 = require("./field-aggregations/create-field-aggregation");
const global_node_projection_1 = require("../utils/global-node-projection");
const get_relationship_direction_1 = require("../utils/get-relationship-direction");
const resolveTree_1 = require("./utils/resolveTree");
const utils_2 = require("../utils/utils");
const CypherBuilder = __importStar(require("./cypher-builder/CypherBuilder"));
const create_projection_subquery_1 = require("./projection/subquery/create-projection-subquery");
const collect_union_subqueries_results_1 = require("./projection/subquery/collect-union-subqueries-results");
// eslint-disable-next-line import/no-cycle
const create_interface_projection_and_params_1 = __importDefault(require("./create-interface-projection-and-params"));
function createProjectionAndParams({ resolveTree, node, context, chainStr, varName, literalElements, resolveType, inRelationshipProjection, isRootConnectionField, isInCypher = false, // Note, only used for connection in cypher fields
 }) {
    function reducer(res, field) {
        const alias = field.alias;
        let param = "";
        if (chainStr) {
            param = `${chainStr}_${alias}`;
        }
        else {
            param = `${varName}_${alias}`;
        }
        const whereInput = field.args.where;
        const optionsInput = (field.args.options || {});
        const fieldFields = field.fieldsByTypeName;
        const cypherField = node.cypherFields.find((x) => x.fieldName === field.name);
        const relationField = node.relationFields.find((x) => x.fieldName === field.name);
        const connectionField = node.connectionFields.find((x) => x.fieldName === field.name);
        const pointField = node.pointFields.find((x) => x.fieldName === field.name);
        const temporalField = node.temporalFields.find((x) => x.fieldName === field.name);
        const authableField = node.authableFields.find((x) => x.fieldName === field.name);
        if (authableField) {
            if (authableField.auth) {
                const allowAndParams = (0, create_auth_and_params_1.createAuthAndParams)({
                    entity: authableField,
                    operations: "READ",
                    context,
                    allow: { parentNode: node, varName, chainStr: param },
                });
                if (allowAndParams[0]) {
                    if (!res.meta.authValidateStrs) {
                        res.meta.authValidateStrs = [];
                    }
                    res.meta.authValidateStrs?.push(allowAndParams[0]);
                    res.params = { ...res.params, ...allowAndParams[1] };
                }
            }
        }
        if (cypherField) {
            const projectionAuthStrs = [];
            const unionWheres = [];
            let projectionStr = "";
            const isArray = cypherField.typeMeta.array;
            const graphqlType = context.schema.getType(cypherField.typeMeta.name);
            const referenceNode = context.nodes.find((x) => x.name === cypherField.typeMeta.name);
            const referenceUnion = graphqlType instanceof graphql_1.GraphQLUnionType ? graphqlType.astNode : undefined;
            if (referenceNode) {
                const { projection: str, params: p, meta,
                // subqueries, // TODO: properly take care of these subqueries
                 } = createProjectionAndParams({
                    resolveTree: field,
                    node: referenceNode || node,
                    context,
                    varName: `${varName}_${alias}`,
                    chainStr: param,
                    isRootConnectionField,
                    inRelationshipProjection: true,
                    isInCypher: true,
                });
                projectionStr = str;
                res.params = { ...res.params, ...p };
                if (meta?.authValidateStrs?.length) {
                    projectionAuthStrs.push(meta.authValidateStrs.join(" AND "));
                }
            }
            if (referenceUnion) {
                const fieldFieldsKeys = Object.keys(fieldFields);
                const hasMultipleFieldFields = fieldFieldsKeys.length > 1;
                const hasSingleFieldField = fieldFieldsKeys.length === 1;
                const headStrs = [];
                let referencedNodes = referenceUnion?.types
                    ?.map((u) => context.nodes.find((n) => n.name === u.name.value))
                    ?.filter((b) => b !== undefined) || [];
                if (hasMultipleFieldFields) {
                    referencedNodes = referencedNodes?.filter((n) => fieldFieldsKeys.includes(n?.name ?? "")) || [];
                }
                referencedNodes.forEach((refNode) => {
                    if (refNode) {
                        const labelsStatements = refNode
                            .getLabels(context)
                            .map((label) => `${varName}_${alias}:\`${label}\``);
                        unionWheres.push(`(${labelsStatements.join(" AND ")})`);
                        const innerHeadStr = [
                            `[ ${varName}_${alias} IN [${varName}_${alias}] WHERE (${labelsStatements.join(" AND ")})`,
                        ];
                        if (fieldFields[refNode.name]) {
                            const { projection: str, params: p, meta, } = createProjectionAndParams({
                                resolveTree: field,
                                node: refNode,
                                context,
                                varName: `${varName}_${alias}`,
                            });
                            innerHeadStr.push([
                                `| ${varName}_${alias} { __resolveType: "${refNode.name}", `,
                                ...str.replace("{", "").split(""),
                            ].join(""));
                            res.params = { ...res.params, ...p };
                            if (meta?.authValidateStrs?.length) {
                                projectionAuthStrs.push(meta.authValidateStrs.join(" AND "));
                            }
                        }
                        else {
                            innerHeadStr.push(`| ${varName}_${alias} { __resolveType: "${refNode.name}" } `);
                        }
                        innerHeadStr.push(`]`);
                        headStrs.push(innerHeadStr.join(" "));
                    }
                });
                const isTakeFirstElement = !isArray || hasSingleFieldField;
                projectionStr = `${isTakeFirstElement ? "head(" : ""} ${headStrs.join(" + ")} ${isTakeFirstElement ? ")" : ""}`;
            }
            const initApocParamsStrs = [
                ...(context.auth ? ["auth: $auth"] : []),
                ...(context.cypherParams ? ["cypherParams: $cypherParams"] : []),
            ];
            // Null default argument values are not passed into the resolve tree therefore these are not being passed to
            // `apocParams` below causing a runtime error when executing.
            const nullArgumentValues = cypherField.arguments.reduce((r, argument) => ({
                ...r,
                ...{ [argument.name.value]: null },
            }), {});
            const apocParams = Object.entries({ ...nullArgumentValues, ...field.args }).reduce((r, entry) => {
                const argName = `${param}_${entry[0]}`;
                return {
                    strs: [...r.strs, `${entry[0]}: $${argName}`],
                    params: { ...r.params, [argName]: entry[1] },
                };
            }, { strs: initApocParamsStrs, params: {} });
            res.params = {
                ...res.params,
                ...apocParams.params,
                ...(context.cypherParams ? { cypherParams: context.cypherParams } : {}),
            };
            const expectMultipleValues = (referenceNode || referenceUnion) && cypherField.typeMeta.array;
            const apocWhere = projectionAuthStrs.length
                ? `WHERE apoc.util.validatePredicate(NOT (${projectionAuthStrs.join(" AND ")}), "${constants_1.AUTH_FORBIDDEN_ERROR}", [0])`
                : "";
            const unionWhere = unionWheres.length ? `WHERE ${unionWheres.join(" OR ")}` : "";
            const apocParamsStr = `{this: ${chainStr || varName}${apocParams.strs.length ? `, ${apocParams.strs.join(", ")}` : ""}}`;
            const isProjectionStrEmpty = projectionStr.trim().length === 0;
            const apocStr = `${!cypherField.isScalar && !cypherField.isEnum ? `${param} IN` : ""} apoc.cypher.runFirstColumn${expectMultipleValues ? "Many" : "Single"}("${cypherField.statement}", ${apocParamsStr})${apocWhere ? ` ${apocWhere}` : ""}${unionWhere ? ` ${unionWhere} ` : ""}${!isProjectionStrEmpty ? ` | ${!referenceUnion ? param : ""} ${projectionStr}` : ""}`;
            const sortInput = (context.resolveTree.args.sort ??
                context.resolveTree.args.options?.sort ??
                []);
            const isSortArg = sortInput.find((obj) => Object.keys(obj)[0] === alias);
            if (isSortArg) {
                if (!res.meta.cypherSortFields) {
                    res.meta.cypherSortFields = [];
                }
                res.meta.cypherSortFields.push({
                    alias,
                    apocStr,
                });
                if (isRootConnectionField) {
                    res.projection.push(`${alias}: edges.${alias}`);
                    return res;
                }
                if (cypherField.isScalar || cypherField.isEnum) {
                    res.projection.push(`${alias}: ${alias}`);
                    return res;
                }
            }
            if (cypherField.isScalar || cypherField.isEnum) {
                res.projection.push(`${alias}: ${apocStr}`);
                return res;
            }
            if (referenceUnion && cypherField.typeMeta.array) {
                res.projection.push(`${alias}: apoc.coll.flatten([${apocStr}])`);
                return res;
            }
            if (cypherField.typeMeta.array) {
                res.projection.push(`${alias}: [${apocStr}]`);
                return res;
            }
            res.projection.push(`${alias}: head([${apocStr}])`);
            return res;
        }
        if (relationField) {
            const referenceNode = context.nodes.find((x) => x.name === relationField.typeMeta.name);
            if (referenceNode?.queryOptions) {
                optionsInput.limit = referenceNode.queryOptions.getLimit(optionsInput.limit);
            }
            if (relationField.interface) {
                const interfaceResolveTree = field;
                const prevRelationshipFields = [];
                const relationshipField = node.relationFields.find((x) => x.fieldName === interfaceResolveTree.name);
                const interfaceProjection = (0, create_interface_projection_and_params_1.default)({
                    resolveTree: interfaceResolveTree,
                    field: relationshipField,
                    context,
                    nodeVariable: varName,
                    withVars: prevRelationshipFields,
                });
                res.subqueries.push(interfaceProjection);
                res.projection.push(`${field.alias}: ${varName}_${field.name}`);
                return res;
            }
            if (relationField.union) {
                const referenceNodes = context.nodes.filter((x) => relationField.union?.nodes?.includes(x.name) &&
                    (!field.args.where || Object.prototype.hasOwnProperty.call(field.args.where, x.name)));
                const parentNode = new CypherBuilder.NamedNode(chainStr || varName);
                const unionSubqueries = [];
                const unionVariableName = `${param}`;
                for (const refNode of referenceNodes) {
                    const refNodeInterfaceNames = node.interfaces.map((implementedInterface) => implementedInterface.name.value);
                    const hasFields = Object.keys(field.fieldsByTypeName).some((fieldByTypeName) => [refNode.name, ...refNodeInterfaceNames].includes(fieldByTypeName));
                    const recurse = createProjectionAndParams({
                        resolveTree: field,
                        node: refNode,
                        context,
                        varName: `${varName}_${alias}`,
                        chainStr: unionVariableName,
                        inRelationshipProjection: true,
                        isRootConnectionField,
                    });
                    res.params = { ...res.params, ...recurse.params };
                    const direction = (0, get_relationship_direction_1.getRelationshipDirection)(relationField, field.args);
                    let nestedProjection = [
                        ` { __resolveType: "${refNode.name}", `,
                        recurse.projection.replace("{", ""),
                    ].join("");
                    if (!hasFields) {
                        nestedProjection = `{ __resolveType: "${refNode.name}" }`;
                    }
                    const subquery = (0, create_projection_subquery_1.createProjectionSubquery)({
                        parentNode,
                        whereInput: field.args.where ? field.args.where[refNode.name] : field.args.where,
                        node: refNode,
                        context,
                        alias: unionVariableName,
                        nestedProjection,
                        nestedSubqueries: recurse.subqueries,
                        relationField,
                        relationshipDirection: direction,
                        optionsInput,
                        authValidateStrs: recurse.meta?.authValidateStrs,
                        addSkipAndLimit: false,
                        collect: false,
                    });
                    const unionWith = new CypherBuilder.With(parentNode);
                    unionSubqueries.push(CypherBuilder.concat(unionWith, subquery));
                }
                const unionClause = new CypherBuilder.Union(...unionSubqueries);
                const collectAndLimitStatements = (0, collect_union_subqueries_results_1.collectUnionSubqueriesResults)({
                    resultVariable: new CypherBuilder.NamedNode(unionVariableName),
                    optionsInput,
                    isArray: Boolean(relationField.typeMeta.array),
                });
                const unionAndSort = CypherBuilder.concat(new CypherBuilder.Call(unionClause), collectAndLimitStatements);
                res.subqueries.push(new CypherBuilder.Call(unionAndSort).with(parentNode));
                res.projection.push(`${alias}: ${unionVariableName}`);
                return res;
            }
            const recurse = createProjectionAndParams({
                resolveTree: field,
                node: referenceNode || node,
                context,
                varName: `${varName}_${alias}`,
                chainStr: param,
                inRelationshipProjection: true,
                isRootConnectionField,
            });
            res.params = { ...res.params, ...recurse.params };
            const parentNode = new CypherBuilder.NamedNode(chainStr || varName);
            const direction = (0, get_relationship_direction_1.getRelationshipDirection)(relationField, field.args);
            const subquery = (0, create_projection_subquery_1.createProjectionSubquery)({
                parentNode,
                whereInput,
                node: referenceNode,
                context,
                alias: param,
                nestedProjection: recurse.projection,
                nestedSubqueries: recurse.subqueries,
                relationField,
                relationshipDirection: direction,
                optionsInput,
                authValidateStrs: recurse.meta?.authValidateStrs,
            });
            res.subqueries.push(new CypherBuilder.Call(subquery).with(parentNode));
            res.projection.push(`${alias}: ${param}`);
            return res;
        }
        const aggregationFieldProjection = (0, create_field_aggregation_1.createFieldAggregation)({
            context,
            nodeLabel: chainStr || varName,
            node,
            field,
        });
        if (aggregationFieldProjection) {
            res.projection.push(`${alias}: ${aggregationFieldProjection.query}`);
            res.params = { ...res.params, ...aggregationFieldProjection.params };
            return res;
        }
        if (connectionField) {
            if (!inRelationshipProjection) {
                if (!res.meta.connectionFields) {
                    res.meta.connectionFields = [];
                }
                res.meta.connectionFields.push(field);
                res.projection.push(literalElements ? `${alias}: ${alias}` : `${alias}`);
                return res;
            }
            const matchedConnectionField = node.connectionFields.find((x) => x.fieldName === field.name);
            const connection = (0, create_connection_and_params_1.default)({
                resolveTree: field,
                field: matchedConnectionField,
                context,
                nodeVariable: varName,
            });
            const paramsWithReplaceMe = connection[1];
            // Only for connections on a @cypher property
            if (isInCypher) {
                const connectionParamNames = Object.keys(connection[1]);
                const runFirstColumnParams = [
                    ...[`${chainStr}: ${chainStr}`],
                    ...connectionParamNames
                        .filter(Boolean)
                        .map((connectionParamName) => `${connectionParamName}: $${connectionParamName}`),
                    ...(context.auth ? ["auth: $auth"] : []),
                    ...(context.cypherParams ? ["cypherParams: $cypherParams"] : []),
                ];
                res.projection.push(`${field.name}: apoc.cypher.runFirstColumnSingle("${connection[0].replace(/("|')/g, "\\$1")} RETURN ${field.name}", { ${runFirstColumnParams.join(", ")} })`);
            }
            else {
                const connectionClause = new CypherBuilder.RawCypher((_env) => {
                    // TODO: avoid REPLACE_ME in params and return them here
                    return [connection[0], {}];
                });
                res.subqueries.push(connectionClause);
                res.projection.push(`${field.name}: ${field.name}`);
            }
            res.params = { ...res.params, ...paramsWithReplaceMe };
            return res;
        }
        if (pointField) {
            res.projection.push((0, create_point_element_1.default)({ resolveTree: field, field: pointField, variable: varName }));
        }
        else if (temporalField?.typeMeta.name === "DateTime") {
            res.projection.push((0, create_datetime_element_1.createDatetimeElement)({ resolveTree: field, field: temporalField, variable: varName }));
        }
        else {
            // In the case of using the @alias directive (map a GraphQL field to a db prop)
            // the output will be RETURN varName {GraphQLfield: varName.dbAlias}
            const dbFieldName = (0, map_to_db_property_1.default)(node, field.name);
            // If field is aliased, rename projected field to alias and set to varName.fieldName
            // e.g. RETURN varname { .fieldName } -> RETURN varName { alias: varName.fieldName }
            let aliasedProj;
            if (alias !== field.name || dbFieldName !== field.name || literalElements) {
                aliasedProj = `${alias}: ${varName}`;
            }
            else {
                aliasedProj = "";
            }
            res.projection.push(`${aliasedProj}.${dbFieldName}`);
        }
        return res;
    }
    let existingProjection = { ...resolveTree.fieldsByTypeName[node.name] };
    // If we have a query for a globalNode and it includes the "id" field
    // we modify the projection to include the appropriate db fields
    if (node.isGlobalNode && existingProjection.id) {
        existingProjection = (0, global_node_projection_1.addGlobalIdField)(existingProjection, node.getGlobalIdField());
    }
    // Fields of reference node to sort on. Since sorting is done on projection, if field is not selected
    // sort will fail silently
    const sortFieldNames = (resolveTree.args.options?.sort ?? []).map(Object.keys).flat();
    // Iterate over fields name in sort argument
    const nodeFields = sortFieldNames.reduce((acc, sortFieldName) => ({
        ...acc,
        // If fieldname is not found in fields of selection set
        ...(!Object.values(existingProjection).find((field) => field.name === sortFieldName)
            ? // generate a basic resolve tree
                (0, resolveTree_1.generateProjectionField)({ name: sortFieldName })
            : {}),
    }), 
    // and add it to existing fields for projection
    existingProjection);
    // Include fields of implemented interfaces to allow for fragments on interfaces
    // cf. https://github.com/neo4j/graphql/issues/476
    const mergedSelectedFields = (0, utils_1.mergeDeep)([
        nodeFields,
        ...node.interfaces.map((i) => resolveTree.fieldsByTypeName[i.name.value]),
    ]);
    // Merge fields for final projection to account for multiple fragments
    // cf. https://github.com/neo4j/graphql/issues/920
    const mergedFields = (0, utils_1.mergeDeep)([
        mergedSelectedFields,
        generateMissingOrAliasedSortFields({ selection: mergedSelectedFields, resolveTree }),
        generateMissingOrAliasedRequiredFields({ selection: mergedSelectedFields, node }),
    ]);
    const { projection, params, meta, subqueries } = Object.values(mergedFields).reduce(reducer, {
        projection: resolveType ? [`__resolveType: "${node.name}"`] : [],
        params: {},
        meta: {},
        subqueries: [],
    });
    return {
        projection: `{ ${projection.join(", ")} }`,
        params,
        meta,
        subqueries,
    };
}
exports.default = createProjectionAndParams;
// Generates any missing fields required for sorting
const generateMissingOrAliasedSortFields = ({ selection, resolveTree, }) => {
    const sortFieldNames = (0, utils_2.removeDuplicates)((resolveTree.args.options?.sort ?? []).map(Object.keys).flat());
    return (0, resolveTree_1.generateMissingOrAliasedFields)({ fieldNames: sortFieldNames, selection });
};
// Generated any missing fields required for custom resolvers
const generateMissingOrAliasedRequiredFields = ({ node, selection, }) => {
    const requiredFields = (0, utils_2.removeDuplicates)((0, resolveTree_1.filterFieldsInSelection)({ fields: node.computedFields, selection })
        .map((f) => f.requiredFields)
        .flat());
    return (0, resolveTree_1.generateMissingOrAliasedFields)({ fieldNames: requiredFields, selection });
};
//# sourceMappingURL=create-projection-and-params.js.map